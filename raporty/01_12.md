# Raport Postępu Prac Projektowych – Etap 2

**Temat:** Opracowanie systemu wizyjnego „Cyber Trener” – Obsługa Wielu Kamer i Wielowątkowość  
**Zespół:** T. Grala, U. Szmit, T. Kot, S. Pokora  
**Data:** 01.12.2025  
**Status:** Zakończony

## 1. Cel i Zakres Etapu
Głównym celem drugiego etapu prac była ewolucja systemu z prostej aplikacji jednowątkowej (MVP) do zaawansowanego rozwiązania zdolnego do **jednoczesnej analizy obrazu z dwóch perspektyw** (przód + bok). Kluczowym wymaganiem była integracja zewnętrznego źródła obrazu (telefon z aplikacją IP Webcam) oraz zapewnienie płynności działania poprzez wprowadzenie współbieżności.

## 2. Zrealizowane Zadania (Realizacja Programowa)

### A. Architektura Wielowątkowa (`core/camera_stream.py`)
Zaimplementowano klasę `CameraStream`, która rozwiązała problem blokowania głównej pętli programu przez operacje wejścia/wyjścia (I/O).
* **Mechanizm:** Pobieranie klatek odbywa się w tle (osobny wątek `threading.Thread`), dzięki czemu główna pętla `main.py` zawsze ma dostęp do najświeższej gotowej klatki.
* **Optymalizacja Sieciowa:** Dla kamer IP zastosowano parametr `cv2.CAP_PROP_BUFFERSIZE = 1`, co wyeliminowało problem narastającego opóźnienia (lagu) przy transmisji przez Wi-Fi.

### B. Obsługa Hybrydowa Źródeł
System został przystosowany do pracy w środowisku mieszanym. W pliku `config.py` i `main.py` zaimplementowano logikę, która automatycznie rozpoznaje typ źródła:
* **USB (Lokalne):** Priorytet szybkości (wymuszenie kodeka MJPG, rozdzielczość HD).
* **IP (Sieciowe):** Priorytet niskiego opóźnienia (obsługa protokołu HTTP/RTSP).
Umożliwia to elastyczną konfigurację, np. *Kamera 1 (Laptop)* + *Kamera 2 (Telefon)*.

### C. Nowy Interfejs Graficzny (`ui/dashboard.py`)
Zastąpiono prosty podgląd nowym modułem `CyberDashboard` o stylistyce inspirowanej interfejsami sci-fi ("Cyberpunk"), co zwiększyło czytelność w trudnych warunkach oświetleniowych.
* **Układ:** Ekran podzielono na sekcję analityczną (lewa strona: paski postępu dla stawów) oraz wizualną (prawa strona).
* **Dual View:** Zaimplementowano dynamiczny układ wyświetlania dwóch kamer jedna pod drugą, co pozwala trenerowi na jednoczesną ocenę sylwetki z przodu i z boku.

### D. Równoległa Detekcja Pose Estimation
Zaktualizowano silnik (`main.py`) do obsługi dwóch niezależnych instancji modelu MediaPipe (`PoseDetector`).
* System analizuje szkielet na obu obrazach niezależnie.
* Wprowadzono logikę wyboru "lepszego widoku" – jeśli kamera boczna widzi punkty kluczowe (np. kąt kolana), system automatycznie uwzględnia te dane w raportach.

## 3. Napotkane Problemy i Rozwiązania

| Problem | Opis | Zastosowane Rozwiązanie |
| :--- | :--- | :--- |
| **Opóźnienia Wi-Fi** | Obraz z telefonu miał 2-3 sekundy opóźnienia względem kamery USB. | Redukcja bufora wewnętrznego OpenCV do 1 klatki w klasie `CameraStream`. |
| **Spadek FPS** | Uruchomienie dwóch sieci neuronowych na CPU obciążyło system (<10 FPS). | Zmiana parametru `model_complexity` z 2 (Heavy) na 1 (Balanced) lub 0 (Lite). |
| **Synchronizacja** | Kamery startowały w różnym czasie. | Dodanie pętli oczekiwania ("Warm-up") i obsługi wyjątków przy braku połączenia. |

## 4. Podsumowanie i Wnioski
Etap 2 zakończył się sukcesem. System **Cyber Trener** działa stabilnie w konfiguracji dwukamerowej. Osiągnięto założoną w `README.md` funkcjonalność "pobierania dwóch strumieni bez opóźnień".

Architektura kodu została zrefaktoryzowana (podział na `core`, `ui`, `config`), co ułatwi implementację logiki biznesowej w kolejnym etapie.

## 5. Plan na Etap 3 (Logika Trenera)
* Implementacja **Maszyny Stanów (State Machine)** do wykrywania faz ćwiczenia (Start -> Ruch w dół -> Ruch w górę -> Stop).
* Opracowanie algorytmu **korekcji błędów** dla przysiadu (wykorzystanie danych z kamery bocznej do oceny pochylenia pleców).
* Integracja pierwszej wersji komend głosowych.